# スマートフォン向けチケットカレンダー UI 要件

## 1. ゴールと前提

- Firestore `realtimeEvents` をカレンダー状に可視化し、ユーザーが日付別にチケット情報を確認できるようにする。
- 最初に想定するデバイスはスマートフォン。4〜6 インチの表示領域での可読性と操作性を最優先。
- データは最大でも 1 時間毎に更新される想定。Firestore 読み込み回数の削減（コスト最適化）を意識してフェッチの仕組みを設計する。
- UI は Next.js / React ベースで構築。Tailwind / CSS modules など既存スタックを踏襲。

## 2. 情報アーキテクチャと画面概要

### 2.1 画面構成

1. **App Shell / Header**
   - ページタイトル（「謎チケ売りますカレンダー」）
   - 更新時刻表示（例: 「最終更新: 11/06 13:15」）
   - クエリ切り替えドロップダウン（`sourceQuery` の候補）またはタブ。
2. **カレンダービュー**
   - 月または週単位の表示を選択可能（スマホ初期表示は週 → スワイプで月にも切替）。
   - 各日付セルに複数イベントの「ミニカード」を縦に最大 3 件まで表示（`ticketTitle` と時刻を簡潔に）。4 件目以降は「+X 件」を表示し、タップで一覧モーダルを開く。
   - スクロール/スワイプ対応。カレンダー自体は 1 画面に収まる高さで固定し、日付セル内のタップで個々のイベント詳細モーダルへ遷移。
3. **モーダル（イベント詳細）**
   - 日付セル内のイベントタイトルをタップすると開く。選択イベントにフォーカスした状態で日付内の他イベントにもスワイプ/タブで移動可能。
   - クローズボタン（上部固定）と前後イベントのナビゲーション矢印を設置。

### 2.2 情報表示（イベント詳細）

- 必須項目: `ticketTitle` / `hashtags` / `eventTime` / `location` / `price` / `quantity` / `authorName` / `authorImageUrl`/ `rawPostText`
- 元ポストリンク (`postURL`) は「X で見る」ボタンなどで提供。
- ユーザーへのリンクも「アイコン画像」などで提供。

## 3. UI デザイン要件（モバイル優先）

### 3.1 カレンダー（日付セル）

- 週表示: 1 列 7 日。上下余白を分厚く取らず、指でタップしやすい高さ（56px 以上）。
- 各セル内レイアウト:
  1. 上部に日付番号＋当日ハイライト（薄いアクセントカラー）
  2. 中央部にイベントミニカードのリスト（タイトル＋開始時刻）。カテゴリ色で左ラインやドットを表示し視認性向上。
  3. 3 件超過時に「+X 件」ボタンを表示。押下で当日イベント一覧モーダルを開く。
- イベントなし日: 「イベントなし」ラベル（グレー）。セル全体をタップ可だがモーダルは開かない。

### 3.2 モーダル詳細

- ヘッダー: 選択日（例: `11/10(月)`）＋クローズアイコン。
- イベントリスト: 各カードの構造例
  ```
  [カテゴリラベル] [信頼度バッジ]
  タイトル（ticketTitle or ハッシュタグ）
  時間・場所：20:00 / 渋谷駅
  価格・枚数：6,500円 / 2枚
  [Xで見る]  等のボタン
  ```
- `needsReview=true` の場合、カード全体に警告アイコン＋背景色変更。
- `notes` や `matched` 情報は折りたたみセクションに収納。

### 3.3 アニメーション / 遷移

- モーダルは下からフェードアップ。カレンダーは選択セルのみ軽微なスケールアップ。

## 4. データ取得とキャッシュ戦略

### 4.1 Firestore 読み込み最適化

- **サーバー側キャッシュ**: API Route で `revalidate` / `cache-control` を設定し、同じクエリに対して 1 分〜5 分程度キャッシュ。
- **クライアントキャッシュ**: SWR or React Query を利用して、同じクエリ範囲をローカルキャッシュ。キーは `(sourceQuery, monthRange)`。
- **範囲フェッチ**: `eventTime` の範囲クエリを利用し、表示期間（例: 4 週間）に必要なデータのみ取得。
- **Prefetch**: 月ビューの場合、前後 1 週間ぶんを先読みしておく。

### 4.2 更新頻度と差分取得

- 1 時間毎にデータが更新される前提のため、クライアントは「手動更新」ボタン＋バックグラウンド再取得（focus 時）で十分。
- 差分更新：`lastSeenAt`（クライアント側 state）より新しい `capturedAt` を持つドキュメントのみ再取得するロジックを検討（サーバー API 側でサポート）。

### 4.3 Firestore 読み込み削減テクニック

- コレクション group クエリ不要、`realtimeEvents` 単一コレクションで `sourceQuery` + `eventTime` インデックス。
- モーダル開時に再読込しない。既に取得済みデータから詳細を表示。
- バッチサイズ: 1 回のクエリで最大 100 件（Firestore 無料枠コストを考慮）。
- Offline persistence（IndexedDB）を有効化すると再訪時の読み込み減少に寄与。

## 5. 状態管理・アーキテクチャ

- **データレイヤー**: `/api/calendar` の API Route を用意し、Firestor クエリ（`from` `to` `sourceQuery`）で JSON を返す。
- **クライアント**: React Query（TanStack）で API を叩き、`staleTime=60 * 1000`（1 分）などを設定。
- **UI 状態**: Recoil や Zustand ではなく、React Context で「現在の表示期間」「選択日」「選択イベント」を管理するのがシンプル。
- **メモリ使用量**: 1 か月分でも数百件程度なら許容。`eventTime` で日別グルーピングした map を生成し、カレンダー表示に利用。

## 6. モーダル内 UX 詳細

- **同日複数イベント**: アコーディオンやタブでカテゴリごとにまとめるオプションを検討（初期実装はシンプルに時刻順で表示）。
- **スワイプ操作**: モーダル内で左右スワイプ → 前日／翌日への切り替え対応（モバイル UX 向上）。
- **共有機能**: `share` ボタン（Web Share API）。`navigator.share` 対応端末で postURL を共有。
- **コピー機能**: `rawPostText` や概要をコピーする CTA を配置。
- **信頼度表示**: `confidence` 数値を 0〜1→ 百分率に変換し、色付きバーで視覚化。

## 7. エンプティ／エラーハンドリング

- イベントがゼロの日 → 「イベントなし」プレースホルダ表示。
- 現在表示期間にイベントが存在しない場合 → カレンダー中央にイラスト＋メッセージ。
- Firestore/API エラー → リトライボタン＋エラートースト。
- フェッチ中 → カレンダー上に Skeleton / shimmer。モーダルはローディングインジケータ。

## 8. アクセシビリティ / 国際化

- ARIA 属性: モーダルに `role="dialog"` を指定し、フォーカスを閉じる -> 元のセルへ戻す。
- キーボードナビゲーション（将来的に PC ビューへ拡張）を想定し、タブ順を整理。
- 日付表記はロケールに合わせて変更可能な設計（初期値: `ja-JP`）。
- 配色は WCAG AA を満たすコントラストを意識。

## 9. テクニカルタスク一覧

1. `GET /api/calendar` API の新設（`sourceQuery`, `from`, `to` パラメータ）。`revalidate` + Firestore キャッシュ。
2. フロントで React Query 設定、および日別グルーピングロジック実装。
3. カレンダー UI コンポーネント（週ビュー＆月ビュー）。スマホ向けレスポンシブデザイン。
4. モーダルコンポーネント＋イベントカードコンポーネント。
5. スワイプ/タップの操作テスト（実機 or ブラウザのデバイスモード）。
6. Firestore 読み込み削減のためのキャッシュ挙動確認（staleTime、prefetch 等）。
7. `navigator.share` 等の機能テスト（対応端末での確認）。

## 10. 今後の検討事項

- `needsReview` イベントの扱い（別タブでレビュー担当者向け UI を用意するか）。
- 通知機能: 新しいイベントが追加された際のプッシュ通知 or メール。
- オフライン対応: Firestore Offline Persistence や PWA 化。
- カテゴリ別フィルタリング／タグフィルタを UI に追加するタイミング。

以上をベースに、モバイル優先のカレンダー UI 実装を進める。
